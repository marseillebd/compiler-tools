module Language.CCS.Lexer.NoiseReduction
  ( CCS(..)
  , Token(..)
  , StrToken(..)
  , PunctuationType(..)
  , pipeline
  , DeleteComment(..)
  , RaiseIllegalBytes(..)
  , WhitespaceError(..)
  ) where

import Control.Monad (when)
import Data.Function ((&))
import GHC.Records (HasField(..))
import Language.CCS.Error (internalError, unused)
import Language.CCS.Lexer.Morpheme (EolType(..))
import Language.Location (Span)
import Language.Nanopass (deflang, defpass)
import Language.Text (SrcText)
import Streaming.Prelude (yield)
import Streaming (Stream, Of(..))

import qualified Language.CCS.Lexer.Morpheme as L0
import qualified Streaming as S
import qualified Streaming.Prelude as S

[deflang|
(CCS from L0:CCS
  (* Token
    (- Comment)
    (- Illegal)
  )
  (* StrToken
    (- IllStr)
  )
)
|]

deriving instance Show Token
deriving instance Show StrToken
deriving instance Show PunctuationType
deriving instance Eq PunctuationType

instance HasField "span" Token Span where
  getField (Symbol a) = a.span
  getField (Number a _ _ _ _ _) = a
  getField (Str a _ _ _) = a
  getField (MlDelim a) = a.span
  getField (MlContent a) = a.span
  getField (MlClose a) = a
  getField (Punctuation a _) = a
  getField (Whitespace a) = a.span
  getField (Eol a _) = a

$(pure [])
[defpass|(from L0:CCS to CCS)|]

_ignore :: ()
_ignore = unused (XlateI, descendTokenI, descendStrTokenI, descendPunctuationTypeI)

xlate :: RaiseIllegalBytes m => Xlate m
xlate = Xlate
  { onToken = \case
      L0.Str l open body close -> Just $ do
        body' <- strDeletions body
        pure $ Str l open body' close
      _ -> Nothing
  , onStrToken = const Nothing
  , onPunctuationType = const Nothing
  , onTokenComment = \_ -> internalError "attempt to translate Comment token to next lexing stage"
  , onTokenIllegal = \_ -> internalError "attempt to translate Illegal token to next lexing stage"
  , onStrTokenIllStr = \_ -> internalError "attempt to translate IllStr token to next lexing stage"
  }

xlateTok :: RaiseIllegalBytes m => L0.Token -> m Token
xlateTok = descendToken xlate

xlateStr :: RaiseIllegalBytes m => L0.StrToken -> m StrToken
xlateStr = descendStrToken xlate

-- | Gets rid of comments, then trailing whitespace.
-- Raises an error on illegal tokens.
-- It also checks that the file has consistent newline sequences, and that it ends in a newline.
-- The caller gets the chance to do something with comments before their removal.
-- Likewise, the caller gets to choose whether to abort or do error recovery on illegal tokens.
pipeline ::
  ( DeleteComment m
  , RaiseIllegalBytes m
  , WhitespaceError m )
  => Stream (Of L0.Token) m r
  -> Stream (Of Token) m r
pipeline input
  = input
  & consistentNewlines Nothing
  & endsInNewline
  & simpleDeletions
  & dedupeWs
  & dedupeEol

simpleDeletions ::
  ( DeleteComment m
  , WhitespaceError m
  , RaiseIllegalBytes m )
  => Stream (Of L0.Token) m r
  -> Stream (Of Token) m r
simpleDeletions = loop
  where
  loop inp0 = S.effect $ S.next inp0 >>= \case
  -- raise error and delete illegal tokens
    Right (L0.Illegal txt, inp1) -> do
      raiseIllegalBytesOrChars txt
      pure $ loop inp1
  -- delete and notify about raw trailing whitespace
    Right (L0.Whitespace ws, inp1) -> S.next inp1 >>= \case
      Right (eol@(L0.Eol _ _), inp2) -> do
        raiseTrailingWhitespace ws.span
        let rest = yield eol >> inp2
        pure $ loop rest
      Right (other, inp2) -> pure $ do
        yield $ Whitespace ws
        let rest = yield other >> inp2
        loop rest
      Left r -> do
        raiseTrailingWhitespace ws.span
        pure $ pure r
  -- delete comment tokens
    Right (L0.Comment txt, inp1) -> do
      deleteComment txt
      pure $ loop inp1
  -- base cases
    Right (other, rest) -> do
      other' <- xlateTok other
      pure $ yield other' >> loop rest
    Left r -> pure $ pure r

strDeletions :: RaiseIllegalBytes m
  => [L0.StrToken]
  -> m [StrToken]
strDeletions (L0.IllStr err : rest) = do
  raiseIllegalBytesOrChars err
  strDeletions rest
strDeletions (other : rest) = do
  other' <- xlateStr other
  (other' :) <$> strDeletions rest
strDeletions [] = pure []

dedupeWs ::
  ( Monad m )
  => Stream (Of Token) m r
  -> Stream (Of Token) m r
dedupeWs inp0 = S.effect $ S.next inp0 >>= \case
  Right (ws@(Whitespace _), inp1) -> S.next inp1 >>= \case
-- remove whitespace before whitespace (may have been generated by deletion of illegal tokens)
    Right (ws2@(Whitespace _), rest) -> pure $ do
      dedupeWs $ yield ws2 >> rest
-- remove whitespace before end of line (may be generated by comment deletion)
    Right (nl@(Eol _ _), rest) -> pure $ do
      dedupeWs $ yield nl >> rest
-- remove whitespace before end of file (may be generated by comment deletion)
    Left r -> do
      pure $ pure r
-- leave the rest alone
    Right (other, inp2) -> pure $ do
      yield ws
      let rest = yield other >> inp2
      dedupeWs rest
-- base cases
  Right (other, inp1) ->
    pure $ yield other >> dedupeWs inp1
  Left r -> pure $ pure r

dedupeEol ::
  ( Monad m )
  => Stream (Of Token) m r
  -> Stream (Of Token) m r
dedupeEol = firstLine
  where
  -- remove newlines at the start of the file
  firstLine inp0 = S.effect $ S.next inp0 >>= \case
    Right (Eol _ _, rest) -> pure $ do
      firstLine rest
  -- transfer to the loop otherwise
    Right (other, inp1) -> pure $ do
      let rest = yield other >> inp1
      loop rest
    Left r -> pure $ pure r
  loop inp0 = S.effect $ S.next inp0 >>= \case
    Right (eol@(Eol _ _), inp1) -> S.next inp1 >>= \case
  -- remove newlines before newlines (indicates a blank line after comment, illegal, and trailg ws stripping)
      Right (eol2@(Eol _ _), rest) -> pure $ do
        loop $ yield eol2 >> rest
  -- leave other newlines alone
      Right (other, inp2) -> pure $ do
        yield eol
        let rest = yield other >> inp2
        loop rest
      Left r -> pure $ do
        yield eol
        pure r
  -- base cases
    Right (other, inp1) ->
      pure $ yield other >> loop inp1
    Left r -> pure $ pure r

consistentNewlines ::
  ( WhitespaceError m )
  => Maybe (Span, EolType)
  -> Stream (Of L0.Token) m r
  -> Stream (Of L0.Token) m r
consistentNewlines Nothing = loop
  where
  loop inp0 = S.effect $ S.next inp0 >>= \case
    Left r -> pure $ pure r
    Right (nl@(L0.Eol l ty), rest) ->
      pure $ yield nl >> consistentNewlines (Just (l, ty)) rest
    Right (other, rest) -> pure $ yield other >> loop rest
consistentNewlines (Just (l, ty)) = loop
  where
  loop inp0 = S.effect $ S.next inp0 >>= \case
    Left r -> pure $ pure r
    Right (nl@(L0.Eol l' ty'), rest) -> do
      when (ty /= ty') $ raiseInconsistentNewlines InconsistentNewlines
        { expected = (l, ty)
        , found = (l', ty')
        }
      pure $ yield nl >> loop rest
    Right (other, rest) -> pure $ yield other >> loop rest

endsInNewline ::
  ( WhitespaceError m )
  => Stream (Of L0.Token) m r
  -> Stream (Of L0.Token) m r
endsInNewline inp0 = S.effect $ S.next inp0 >>= \case
-- at last token
  Right (x, inp1) -> S.next inp1 >>= \case
    Left r -> do
      case x of
        L0.Eol l Eof -> raiseNoNlAtEof l
        _ -> pure ()
      pure $ yield x >> pure r
-- not at last token
    Right (y, inp2) -> do
      let rest = yield y >> inp2
      pure $ yield x >> endsInNewline rest
  Left r -> pure $ pure r

class Monad m => DeleteComment m where
  -- | For most purposes, we'd just strip comments out of the token stream with no fanfare.
  -- Indeed, a valid implementation just ignores the comment Span and 'Text' and returns the unit.
  --
  -- However, we might have a processor that would like to
  -- - search comments for tags like todo or debug
  -- - lint the comment text for style (like looking for typos, or ensuring there's a space after the hash)
  -- - keep the comment around for later, when perhaps it attaches to some nearby bit of code
  --   (this is often used for documentation, but I don't recommend it personally.
  --   I think comments should be there for the person who is reading the code, and no one and nothing else.)
  deleteComment :: SrcText -> m ()

-- Instead of directly erroring out, allow the caller to decide:
-- - should we recover from the error and continue? (my morphemes, we already have)
-- - should I merge adjacent illegal bytes?
-- - how should the errors be reported?
class Monad m => RaiseIllegalBytes m where
  -- TODO someday, I'll distinguish between decoding errors and illegal codepoints
  -- also bad bytes are just being replaced by the unicode Replacement Character
  raiseIllegalBytesOrChars :: SrcText -> m ()

data InconsistentNewlines = InconsistentNewlines
  { expected :: (Span, EolType)
  , found :: (Span, EolType)
  }
  deriving (Show)
class Monad m => WhitespaceError m where
  raiseTrailingWhitespace :: Span -> m ()
  raiseInconsistentNewlines :: InconsistentNewlines -> m ()
  raiseNoNlAtEof :: Span -> m ()
