# Work Log

## Rewrite Coverage Lexer

Last time, I want's feeling confident in lexeme assembly.
Since then, I've done some writing in the standard trying to describe the process more abstractly.
What I found was that the regular expressions for tokens weren't particularly diffcult.
So, I decided to re-write the coverage lexer.

A key step in this is using the `SrcText` type and associated parsers.
This also meant that I could eliminate several `unwrapOrPanic` calls related to making spans.

### Future Work

The parsers for `SrcText` are a particularly ugly and ad-hoc set.
If I'm to publish the `source-location` package, I'll need to clean these up quite dramatically.

I suspect I'll need a `withConsumed :: Parser a -> Parser (SrcText, a)`.
Heck, implementation might be as simple as just runninc the existing `Parser` type inside another.

## Sandhi

I attempted to try designing the sandhi rules in the standard, but ran into thought block very quickly.
It turned out that just sitting down in the code and handling the missing cases as the compiler handed them to me was very effective.

### Future Work

Do I really want to allow dot(s)/colon(s) in all of these places?
Triple colon is unprecedented, and double colon like this is only in Haskell and its syntactic derivatives.
Should there be a difference between double and triple dot?
Do any languages have different meanings for single- vs double-colon in the contexts CSS could let them appear?

## Future Work

### Disallow Tabs Outside Indentation

I notived that I'm not checking against tabs in non-indentation whitespace, which I defo should.
This can be checked in Indentation.hs, and we can then throw away the details of the ws chars at that point too.

### More Info for Errors

The error-raising methods rn only take locations.
These should defo take some more stuff, though I'm wary of exposing the types of internal lexer stages.
Perhaps SrcText would be better?
I'll have to think on it, and perhaps actually render some error messages.
