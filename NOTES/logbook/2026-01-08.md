# Work Log

So, the big thing is that I finished rough drafts of both the parser and the recognizer library.
This means I'm going on to try it out on a real language.
I've decided my "real" language will begin as the untyped lambda calculus, with _no_ adornments.
This will be a small lanugage that can be evaluated (or even compiled to JS) that will show any obvious deficiencies in the compiler tools workflow.
This log is a great place to note any of those problems that I don't address immediately.

# Future Work

- [ ] templates need SrcText, not just Text
- [ ] the context is not getting threaded throuogh for theSpan, and tbh arrows are just largely unfamiliar; perhaps just go with a monadic parser
- [ ] I need to have a ParserError monad, just like my lexer monads.
- [ ] It's quite annoying to not have a type that can hold any lexer/parser error.
- [ ] I'd like a "default" monad that collects errors, exiting where reasonable.

I am questioning the usefulness of distinguishing between `f(a, b)` and `f (a, b)`.
We certainly _expect_ `a(1) b[2] c {3}`, and it's rare to see the other variant, much less for it to be distinguished.
Nevertheless, I _do_ want to support the super-nice Haskell-like function application, especially for dependently typed langs.
